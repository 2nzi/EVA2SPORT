"""
Gestionnaire d'√©v√©nements multiples pour EVA2SPORT
G√®re l'index global et les fichiers s√©par√©s par √©v√©nement
"""

import json
from pathlib import Path
from typing import Dict, List, Any, Optional, Union
from datetime import datetime

from ..config import Config
from ..pipeline import EVA2SportPipeline
from ..utils import TimestampReader


class MultiEventManager:
    """Gestionnaire pour traiter plusieurs √©v√©nements avec index global"""
    
    def __init__(self, video_name: str, working_dir: Optional[str] = None):
        """
        Initialise le gestionnaire d'√©v√©nements multiples
        
        Args:
            video_name: Nom de la vid√©o de base (sans suffixe d'√©v√©nement)
            working_dir: R√©pertoire de travail
        """
        self.video_name = video_name
        self.working_dir = Path(working_dir) if working_dir else Path.cwd()
        
        # Chemins pour l'index global - Structure hi√©rarchique
        self.videos_dir = self.working_dir / "data" / "videos"
        self.base_output_dir = self.videos_dir / "outputs"
        self.video_output_dir = self.base_output_dir / video_name
        self.index_file = self.video_output_dir / f"{video_name}_events_index.json"
        
        # Utilitaires - Cr√©er avec une config temporaire pour la r√©solution des chemins
        from ..config import Config
        temp_config = Config(video_name, working_dir, create_directories=False)
        self.timestamp_reader = TimestampReader(temp_config)
        
        # √âtat
        self.events_index = self._load_or_create_index()
        
    def _load_or_create_index(self) -> Dict[str, Any]:
        """Charge ou cr√©e l'index des √©v√©nements"""
        # Cr√©er le dossier de la vid√©o si n√©cessaire
        self.video_output_dir.mkdir(parents=True, exist_ok=True)
        
        if self.index_file.exists():
            with open(self.index_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        else:
            return {
                "video_name": self.video_name,
                "created_at": datetime.now().isoformat(),
                "total_events": 0,
                "events": []
            }
    
    def add_event(self, event_timestamp: float, 
                  segment_offset_before: float = 3.0,
                  segment_offset_after: float = 3.0,
                  **kwargs) -> Dict[str, Any]:
        """
        Ajoute et traite un nouvel √©v√©nement
        
        Args:
            event_timestamp: Timestamp de l'√©v√©nement en secondes
            segment_offset_before: Offset avant l'√©v√©nement
            segment_offset_after: Offset apr√®s l'√©v√©nement
            **kwargs: Autres param√®tres pour la pipeline
            
        Returns:
            R√©sultats du traitement de l'√©v√©nement
        """
        event_id = f"event_{int(event_timestamp)}s"
        
        print(f"üéØ Traitement de l'√©v√©nement: {event_id}")
        print(f"   ‚è∞ Timestamp: {event_timestamp}s")
        
        # V√©rifier si l'√©v√©nement existe d√©j√†
        existing_event = self._find_event_by_id(event_id)
        if existing_event:
            print(f"   ‚ö†Ô∏è √âv√©nement {event_id} existe d√©j√†")
            return existing_event
        
        try:
            # Extraire les param√®tres segment_offset_* des kwargs pour √©viter les conflits
            pipeline_kwargs = kwargs.copy()
            
            # Utiliser les valeurs des kwargs si pr√©sentes, sinon les param√®tres par d√©faut
            segment_offset_before_seconds = kwargs.get('segment_offset_before_seconds', segment_offset_before)
            segment_offset_after_seconds = kwargs.get('segment_offset_after_seconds', segment_offset_after)
            
            # Supprimer ces param√®tres des kwargs pour √©viter les conflits
            pipeline_kwargs.pop('segment_offset_before_seconds', None)
            pipeline_kwargs.pop('segment_offset_after_seconds', None)
            
            # V√©rifier s'il y a des annotations valides AVANT de cr√©er toute config
            if not self._has_valid_annotations_for_event(
                event_timestamp, 
                segment_offset_before_seconds, 
                segment_offset_after_seconds
            ):
                print(f"   ‚ùå √âv√©nement {event_id} ignor√© - pas de tracking possible")
                return None
            
            # Cr√©er et ex√©cuter la pipeline pour cet √©v√©nement
            pipeline = EVA2SportPipeline(
                self.video_name,
                event_timestamp_seconds=event_timestamp,
                segment_offset_before_seconds=segment_offset_before_seconds,
                segment_offset_after_seconds=segment_offset_after_seconds,
                **pipeline_kwargs
            )
            
            # Ex√©cuter la pipeline
            results = pipeline.run_full_pipeline(
                force_extraction=True,
                export_video=True,
                video_params=kwargs.get('video_params', {
                    'fps': 5,
                    'show_minimap': True,
                    'cleanup_frames': True,
                    'force_regenerate': True
                })
            )
            
            if results['status'] == 'success':
                # Ajouter √† l'index
                event_info = {
                    "event_id": event_id,
                    "timestamp_seconds": event_timestamp,
                    "frame_range": [
                        results.get('segment_start_frame', 0),
                        results.get('segment_end_frame', 0)
                    ],
                    "annotation_frame": results.get('reference_frame', 0),
                    "project_file": str(Path(results['export_paths']['json']).relative_to(self.video_output_dir)),
                    "video_file": str(Path(results['export_paths']['video']).relative_to(self.video_output_dir)) if 'video' in results['export_paths'] else None,
                    "objects_count": results['objects_tracked'],
                    "annotations_count": results['total_annotations'],
                    "frames_count": results['frames_extracted'],
                    "status": "completed",
                    "processed_at": datetime.now().isoformat(),
                    "config": {
                        "segment_offset_before": segment_offset_before_seconds,
                        "segment_offset_after": segment_offset_after_seconds,
                        "frame_interval": results['config']['frame_interval']
                    }
                }
                
                self.events_index["events"].append(event_info)
                self.events_index["total_events"] = len(self.events_index["events"])
                self.events_index["last_updated"] = datetime.now().isoformat()
                
                self._save_index()
                
                print(f"   ‚úÖ √âv√©nement {event_id} trait√© avec succ√®s")
                return event_info
            else:
                error_msg = results.get('error', 'Erreur inconnue')
                print(f"   ‚ùå √âchec du traitement de l'√©v√©nement {event_id}: {error_msg}")
                
                # Afficher les d√©tails de l'erreur si disponibles
                if 'error_details' in results and results['error_details']:
                    print(f"   üí• D√©tails de l'erreur:")
                    for line in results['error_details'].split('\n'):
                        if line.strip():
                            print(f"      {line}")
                
                return None
                
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"   ‚ùå Erreur lors du traitement de l'√©v√©nement {event_id}: {e}")
            print(f"   üí• D√©tails de l'erreur:")
            for line in error_details.split('\n'):
                if line.strip():
                    print(f"      {line}")
            return None
    
    def process_multiple_events(self, event_timestamps: Optional[List[float]] = None,
                               csv_file: Optional[Union[str, Path]] = None,
                               json_file: Optional[Union[str, Path]] = None,
                               csv_config: Optional[Dict[str, str]] = None,
                               validate_timestamps: bool = True,
                               **kwargs) -> Dict[str, Any]:
        """
        Traite plusieurs √©v√©nements depuis diff√©rentes sources
        
        Args:
            event_timestamps: Liste manuelle des timestamps d'√©v√©nements
            csv_file: Fichier CSV contenant les timestamps
            json_file: Fichier JSON contenant les timestamps
            csv_config: Configuration pour la lecture CSV (timestamp_column, filter_column, filter_value)
            validate_timestamps: Valider les timestamps contre la dur√©e de la vid√©o
            **kwargs: Param√®tres communs pour tous les √©v√©nements
            
        Returns:
            R√©sum√© du traitement de tous les √©v√©nements
        """
        # R√©cup√©rer les timestamps depuis la source appropri√©e
        timestamps = self._get_timestamps_from_source(
            event_timestamps, csv_file, json_file, csv_config, validate_timestamps
        )
        
        if not timestamps:
            print("‚ùå Aucun timestamp √† traiter")
            return {
                "total_events": 0,
                "successful_events": 0,
                "failed_events": 0,
                "events_details": []
            }
        
        print(f"üöÄ TRAITEMENT DE {len(timestamps)} √âV√âNEMENTS")
        print("=" * 60)
        
        results = {
            "total_events": len(timestamps),
            "successful_events": 0,
            "failed_events": 0,
            "events_details": []
        }
        
        for i, timestamp in enumerate(timestamps):
            print(f"\n--- √âv√©nement {i+1}/{len(timestamps)} ---")
            
            event_result = self.add_event(timestamp, **kwargs)
            
            if event_result:
                results["successful_events"] += 1
                results["events_details"].append({
                    "timestamp": timestamp,
                    "status": "success",
                    "event_id": event_result["event_id"]
                })
            else:
                results["failed_events"] += 1
                results["events_details"].append({
                    "timestamp": timestamp,
                    "status": "failed",
                    "event_id": f"event_{int(timestamp)}s"
                })
        
        print(f"\n{'='*60}")
        print(f"üìä R√âSUM√â DU TRAITEMENT MULTI-√âV√âNEMENTS")
        print(f"   üéØ Total √©v√©nements: {results['total_events']}")
        print(f"   ‚úÖ R√©ussis: {results['successful_events']}")
        print(f"   ‚ùå √âchecs: {results['failed_events']}")
        print(f"   üìÑ Index global: {self.index_file}")
        
        return results
    
    def get_events_list(self) -> List[Dict[str, Any]]:
        """Retourne la liste de tous les √©v√©nements"""
        return self.events_index["events"]
    
    def get_event_by_id(self, event_id: str) -> Optional[Dict[str, Any]]:
        """R√©cup√®re un √©v√©nement par son ID"""
        return self._find_event_by_id(event_id)
    
    def _find_event_by_id(self, event_id: str) -> Optional[Dict[str, Any]]:
        """Trouve un √©v√©nement par son ID"""
        for event in self.events_index["events"]:
            if event["event_id"] == event_id:
                return event
        return None
    
    def _save_index(self):
        """Sauvegarde l'index des √©v√©nements"""
        # S'assurer que le dossier parent existe
        self.index_file.parent.mkdir(parents=True, exist_ok=True)
        with open(self.index_file, 'w', encoding='utf-8') as f:
            json.dump(self.events_index, f, indent=2, ensure_ascii=False)
    
    def _has_valid_annotations_for_event(self, event_timestamp: float,
                                        segment_offset_before_seconds: float,
                                        segment_offset_after_seconds: float) -> bool:
        """
        V√©rifie s'il y a des annotations valides dans l'intervalle de l'√©v√©nement
        SANS cr√©er de config temporaire pour √©viter la cr√©ation de dossiers
        
        Args:
            event_timestamp: Timestamp de l'√©v√©nement
            segment_offset_before_seconds: Offset avant
            segment_offset_after_seconds: Offset apr√®s
            
        Returns:
            True si au moins une annotation est dans l'intervalle
        """
        import json
        import cv2
        
        # Charger la configuration du projet directement
        # Utiliser la config temporaire du timestamp_reader pour la r√©solution des chemins
        temp_config = self.timestamp_reader.config
        config_path = temp_config.config_path
        calib_path = temp_config.videos_dir / f"{self.video_name}_calib.json"
        objects_path = temp_config.videos_dir / f"{self.video_name}_objects.json"
        
        try:
            if calib_path.exists() and objects_path.exists():
                # Nouveau format : deux fichiers
                with open(calib_path, 'r', encoding='utf-8') as f:
                    calib_data = json.load(f)
                with open(objects_path, 'r', encoding='utf-8') as f:
                    objects_data = json.load(f)
                project_config = {**calib_data, **objects_data}
            elif config_path.exists():
                # Ancien format : un seul fichier
                with open(config_path, 'r', encoding='utf-8') as f:
                    project_config = json.load(f)
            else:
                print(f"   ‚ùå Configuration non trouv√©e pour {self.video_name}")
                return False
            
            # R√©cup√©rer les annotations initiales
            initial_annotations = project_config.get('initial_annotations', [])
            if not initial_annotations:
                print(f"   ‚ö†Ô∏è Aucune annotation initiale trouv√©e")
                return False
            
            # R√©cup√©rer le FPS de la vid√©o directement
            video_path = temp_config.video_path
            if not video_path.exists():
                print(f"   ‚ùå Vid√©o non trouv√©e: {video_path}")
                return False
                
            cap = cv2.VideoCapture(str(video_path))
            if not cap.isOpened():
                print(f"   ‚ùå Impossible d'ouvrir la vid√©o: {video_path}")
                return False
                
            fps = cap.get(cv2.CAP_PROP_FPS)
            cap.release()
            
            if fps <= 0:
                fps = 25.0  # Valeur par d√©faut
            
            # Calculer l'event_frame et l'intervalle
            event_frame = int(event_timestamp * fps)
            offset_before_frames = int((segment_offset_before_seconds or 0.0) * fps)
            offset_after_frames = int((segment_offset_after_seconds or 0.0) * fps)
            
            start_frame = max(0, event_frame - offset_before_frames)
            end_frame = event_frame + offset_after_frames
            
            print(f"   ‚ö†Ô∏è V√©rification annotations pour √©v√©nement:")
            print(f"   üìç Event frame: {event_frame}")
            print(f"   üìç Annotations disponibles: {[ann.get('frame', 0) for ann in initial_annotations]}")
            print(f"   üìä Intervalle √©v√©nement: frames {start_frame} √† {end_frame}")
            
            # V√©rifier s'il y a au moins une annotation dans l'intervalle
            for ann in initial_annotations:
                annotation_frame = ann.get('frame', 0)
                if start_frame <= annotation_frame <= end_frame:
                    print(f"   ‚úÖ Annotation valide trouv√©e: frame {annotation_frame}")
                    return True
            
            print(f"   ‚ùå Aucune annotation valide dans l'intervalle")
            return False
            
        except Exception as e:
            print(f"   ‚ùå Erreur lors de la v√©rification des annotations: {e}")
            return False
    
    def _get_timestamps_from_source(self, event_timestamps: Optional[List[float]] = None,
                                   csv_file: Optional[Union[str, Path]] = None,
                                   json_file: Optional[Union[str, Path]] = None,
                                   csv_config: Optional[Dict[str, str]] = None,
                                   validate_timestamps: bool = True) -> List[float]:
        """
        R√©cup√®re les timestamps depuis diff√©rentes sources
        
        Args:
            event_timestamps: Liste manuelle des timestamps
            csv_file: Fichier CSV contenant les timestamps
            json_file: Fichier JSON contenant les timestamps
            csv_config: Configuration pour la lecture CSV
            validate_timestamps: Valider les timestamps contre la dur√©e de la vid√©o
            
        Returns:
            Liste des timestamps √† traiter
        """
        timestamps = []
        
        # Priorit√© 1: Liste manuelle
        if event_timestamps:
            print("üìã Utilisation de la liste manuelle de timestamps")
            timestamps = list(event_timestamps)
        
        # Priorit√© 2: Fichier CSV
        elif csv_file:
            print("üìä Lecture des timestamps depuis un fichier CSV")
            
            # Configuration par d√©faut pour CSV
            csv_config = csv_config or {}
            timestamp_column = csv_config.get('timestamp_column', 'Start time')
            filter_column = csv_config.get('filter_column')
            filter_value = csv_config.get('filter_value')
            
            try:
                timestamps = self.timestamp_reader.read_from_csv(
                    csv_file=csv_file,
                    timestamp_column=timestamp_column,
                    filter_column=filter_column,
                    filter_value=filter_value
                )
            except Exception as e:
                print(f"‚ùå Erreur lors de la lecture du CSV: {e}")
                return []
        
        # Priorit√© 3: Fichier JSON
        elif json_file:
            print("üìÑ Lecture des timestamps depuis un fichier JSON")
            
            try:
                timestamps = self.timestamp_reader.read_from_json(json_file)
            except Exception as e:
                print(f"‚ùå Erreur lors de la lecture du JSON: {e}")
                return []
        
        else:
            print("‚ùå Aucune source de timestamps fournie")
            return []
        
        # Validation des timestamps si demand√©e
        if validate_timestamps and timestamps:
            print("‚úÖ Validation des timestamps contre la dur√©e de la vid√©o")
            timestamps = self.timestamp_reader.validate_timestamps(
                timestamps, self.video_name
            )
        
        return timestamps
    
    def process_events_from_csv(self, csv_file: Union[str, Path],
                               timestamp_column: str = 'Start time',
                               filter_column: Optional[str] = None,
                               filter_value: Optional[str] = None,
                               **kwargs) -> Dict[str, Any]:
        """
        M√©thode de commodit√© pour traiter les √©v√©nements depuis un CSV
        
        Args:
            csv_file: Fichier CSV contenant les timestamps
            timestamp_column: Nom de la colonne contenant les timestamps
            filter_column: Colonne √† utiliser pour filtrer les lignes
            filter_value: Valeur √† rechercher pour filtrer
            **kwargs: Param√®tres communs pour tous les √©v√©nements
            
        Returns:
            R√©sum√© du traitement de tous les √©v√©nements
        """
        csv_config = {
            'timestamp_column': timestamp_column,
            'filter_column': filter_column,
            'filter_value': filter_value
        }
        
        return self.process_multiple_events(
            csv_file=csv_file,
            csv_config=csv_config,
            **kwargs
        )
    
    def get_csv_info(self, csv_file: Union[str, Path]) -> Dict[str, Any]:
        """
        R√©cup√®re les informations sur un fichier CSV
        
        Args:
            csv_file: Chemin vers le fichier CSV
            
        Returns:
            Informations sur le CSV
        """
        return self.timestamp_reader.get_csv_info(csv_file)
    
    def display_events_summary(self):
        """Affiche un r√©sum√© des √©v√©nements"""
        print(f"\nüìã R√âSUM√â DES √âV√âNEMENTS - {self.video_name}")
        print("=" * 50)
        
        if not self.events_index["events"]:
            print("   ‚ùå Aucun √©v√©nement trait√©")
            return
        
        print(f"   üé¨ Vid√©o: {self.video_name}")
        print(f"   üìä Total √©v√©nements: {self.events_index['total_events']}")
        print(f"   üìÖ Cr√©√©: {self.events_index['created_at']}")
        if "last_updated" in self.events_index:
            print(f"   üîÑ Derni√®re mise √† jour: {self.events_index['last_updated']}")
        
        print(f"\n   üìã LISTE DES √âV√âNEMENTS:")
        for i, event in enumerate(self.events_index["events"], 1):
            print(f"      {i}. {event['event_id']}")
            print(f"         ‚è∞ Timestamp: {event['timestamp_seconds']}s")
            print(f"         üìç Frame: {event['annotation_frame']}")
            print(f"         üéØ Objets: {event['objects_count']}")
            print(f"         üìù Annotations: {event['annotations_count']}")
            print(f"         ‚úÖ Status: {event['status']}")
            print(f"         üìÑ Fichier: {event['project_file']}")
            if event['video_file']:
                print(f"         üé¨ Vid√©o: {event['video_file']}")
            print()
        
        print(f"   üìÑ Index global: {self.index_file}") 